<html>
  <head>
    <meta content='Interview Question 2 - shortest path between two vertices, Dijkstra's algorithm - Adam Kenneweg - Computer Science - University of Waterloo - Blog and Projects' property='og:title' />
    <title>Interview Question 2 - shortest path between two vertices, Dijkstra's algorithm - Adam Kenneweg - Computer Science - University of Waterloo - Blog and Projects</title>
    <link href='/images/favicon.ico' rel='shortcut icon'>
<link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css' />
<link href='/stylesheets/style.css' rel='stylesheet' type='text/css' />
<link href='/stylesheets/syntax.css' rel='stylesheet' type='text/css' />
<link href='/stylesheets/responsive.css' rel='stylesheet' type='text/css' />
<!-- - -->
<script src='/javascripts/jquery.js' type='text/javascript'></script>
<script src='/javascripts/pd.js' type='text/javascript'></script>
<script src='/javascripts/basics.js' type='text/javascript'></script>
<script type="text/javascript" src="https://www.google.com/jsapi"></script>
<!-- - -->
<meta content='width=device-width, initial-scale=1.0, user-scalable=no' name='viewport'>
<meta content='text/html; charset=utf-8' http-equiv='content-type' />
<meta content="/og.png" property="og:image" />
<meta content="" property="fb:app_id" />

  <meta content='/projects/2016/01/26/Interview-Questions-2-Shortest-path-between-two-vertices/' property='og:url' />
  <meta content="This is another common interview question at the University of Waterloo, this one is a lot harder than the last one. ..." property='og:description' />
  <meta content="article" property="og:type" />

<!-- - -->
<script type='text/javascript'>
  //<![CDATA[
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-73223947-1']);
    _gaq.push(['_trackPageview']);
    
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  //]]>
</script>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_GB/all.js#xfbml=1&appId=";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

  </head>
  <body>
    <header>
<a id="go-back-home" href="../"><img src="/images/logo.png" alt="scribble" width="500" height="112"></a>
</header>
    <div id='container'>
      <div class="block">
  
    <a target="_top"
       class="main" 
       href="/">
       Home
     </a>
  
    <a target="_top"
       class="main" 
       href="/blog">
       Blog
     </a>
  
    <a target="_top"
       class="main" 
       href="/projects">
       Projects
     </a>
  
    <a target="_top"
       class="main" 
       href="/gallery">
       Gallery
     </a>
  
    <a target="_top"
       class="main" 
       href="/resume.pdf">
       Resume
     </a>
  
</div>
      <section class="paging">
  
    <div class="left">
      <a href="/projects/2016/01/16/Interview-Questions-1-subsets-of-set/">
        â€¹
      </a>
    </div>
  
  
</section>
      <div class="content">
        <section class='post'>
          <h1 class="upcase">
            <div class='date'>26 Jan 2016</div>
            Interview Question 2 - shortest path between two vertices, Dijkstra's algorithm
          </h1>
          <p>This is another common interview question at the University of Waterloo, this one is a lot harder than the last one. You might get this if you are going through one of the big 4&rsquo;s (Facebook, Google, Microsoft, Apple/Amazon) interview process. Something like:</p>

<blockquote>
<p>Given the weighted undirected graph below, find the shortest path between two vertices A and F</p>
</blockquote>

<p><img src="../../../../../images/blog/graph.png" alt="Example graph"></p>

<p>Each line in the graph has a corresponding &ldquo;weight&rdquo; next to it. Undirected, means that you can go in between nodes without restrictions. A real life example of this would be to think of a city: the lines (edges) are streets, which have a length in KM (the weight). The points (vertices) are intersections. Undirected means all streets are two way, directed would mean some are one way. Find the shortest way to get from point a to point f. Now you can easily do this just by looking at it, A to C to D to F. But how do you get code to do it? </p>

<hr>

<p>I am using python3 to solve this problem.</p>

<p>There are a lot of algorithms you can use to solve this problem. A very common and simple one to use for something like this is Dijkstra&rsquo;s algorithm. It looks like below (using our same graph as above):</p>

<p><img src="../../../../../images/blog/dijkstra.gif" alt="Dijkstra&#39;s gif">
<em>Dijkstra&rsquo;s algorithm to find the shortest path between a and b. It picks the unvisited vertex with the lowest-distance, calculates the distance through it to each unvisited neighbor, and updates the neighbor&rsquo;s distance if smaller. Mark visited (set to red) when done with neighbors.</em></p>

<p>We will convert this algorithm to code, step by step.</p>

<p>First our representation of the graph in code form:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">)</span>
<span class="n">distances</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'A'</span><span class="p">:</span> <span class="p">{</span><span class="s">'B'</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">'D'</span><span class="p">:</span> <span class="mi">14</span><span class="p">},</span>
    <span class="s">'B'</span><span class="p">:</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">15</span><span class="p">},</span>
    <span class="s">'C'</span><span class="p">:</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">'B'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'D'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">11</span><span class="p">},</span>
    <span class="s">'D'</span><span class="p">:</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'F'</span><span class="p">:</span> <span class="mi">9</span><span class="p">},</span>
    <span class="s">'E'</span><span class="p">:</span> <span class="p">{</span><span class="s">'B'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s">'F'</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
    <span class="s">'F'</span><span class="p">:</span> <span class="p">{</span><span class="s">'D'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">6</span><span class="p">}}</span>
</code></pre></div>
<p>Step 1: Assign to every node a tentative distance value: set it to zero for our initial node and to infinity for all other nodes.</p>

<p>Step 2: Set the initial node as current. Mark all other nodes unvisited. Create a set of all the unvisited nodes called the unvisited set.</p>

<p>We will create a dictionary of unvisited nodes, where the key is the vertice letter, and the value is the distance. For our distance of infinity, we will just use None.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">unvisited</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span> 
<span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">currentDistance</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">current</span> <span class="o">=</span> <span class="s">'A'</span>
<span class="n">target</span> <span class="o">=</span> <span class="s">'F'</span>
<span class="n">unvisited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentDistance</span>
</code></pre></div>
<p>Step 3: For the current node, consider all of its unvisited neighbors and calculate their tentative distances. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one. For example, if the current node A is marked with a distance of 6, and the edge connecting it with a neighbor B has length 2, then the distance to B (through A) will be 6 + 2 = 8. If B was previously marked with a distance greater than 8 then change it to 8. Otherwise, keep the current value.</p>

<p>We will loop through all the neighbours of our current node(&lsquo;A&rsquo;), by looking at the dictionary for it&rsquo;s distances. The neighbours are anyone it has a distance to.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">neighbour</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c"># only check the unvisited one</span>
        <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">unvisited</span><span class="p">:</span>
            <span class="n">newDistance</span> <span class="o">=</span> <span class="n">currentDistance</span> <span class="o">+</span> <span class="n">distance</span>
            <span class="c"># set its distance to the new one if it is lower</span>
            <span class="c"># remember, none is +Infinity</span>
            <span class="k">if</span> <span class="n">unvisited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">unvisited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">newDistance</span><span class="p">:</span>
                <span class="n">unvisited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="n">newDistance</span>
</code></pre></div>
<p>Step 4: When we are done considering all of the neighbors of the current node, mark the current node as visited and remove it from the unvisited set. A visited node will never be checked again.</p>

<p>Simple enough, move it from unvisited to visited</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">    <span class="c"># still in the while loop, after the for loop</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentDistance</span>
    <span class="k">del</span> <span class="n">unvisited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span>
</code></pre></div>
<p>Step 5: If the destination node has been marked visited (when planning a route between two specific nodes) or if the smallest tentative distance among the nodes in the unvisited set is infinity (when planning a complete traversal; occurs when there is no connection between the initial node and remaining unvisited nodes), then stop. The algorithm has finished.</p>

<p>So we check if our destination is visited, or if there are no more unvisited nodes, or if all the remaining unvisited nodes are infinity. In the last case it means that one of the nodes isn&rsquo;t connected to any of the others.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">    <span class="c"># still in the while loop, after the for loop</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">unvisited</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="c">#node[1] is current distance, get any that aren't infinity (neighbours)</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">unvisited</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> 
    <span class="k">if</span> <span class="ow">not</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">break</span>
</code></pre></div>
<p>Step 6: Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new &ldquo;current node&rdquo;, and go back to step 3.</p>

<p>So we need to sort the neighbours by distance and get the closest one. The key for the sort is going too be x[1], which is the distance.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python">    <span class="c"># still in the while loop, after the for loop</span>
    <span class="c"># sort based on distance (x[1] is current distance), get closest one ([0])</span>
    <span class="n">current</span><span class="p">,</span> <span class="n">currentDistance</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c"># end of while loop, go back to top</span>
</code></pre></div>
<p>And then finally, after the while loop is done</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">print</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
</code></pre></div>
<p>And that&rsquo;s it.</p>

<p>You can also easily find the distance from the start to ALL nodes by making this small change</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># original, point A to F</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">unvisited</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">break</span>

<span class="c"># altered, point A to ALL</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">unvisited</span><span class="p">:</span>
        <span class="k">break</span>

<span class="c"># at the end of the while loop, do</span>
<span class="k">print</span><span class="p">(</span><span class="n">visited</span><span class="p">)</span>
</code></pre></div>
<hr>

<p>The complete code below.</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">)</span>
<span class="n">distances</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'A'</span><span class="p">:</span> <span class="p">{</span><span class="s">'B'</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">'D'</span><span class="p">:</span> <span class="mi">14</span><span class="p">},</span>
    <span class="s">'B'</span><span class="p">:</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">15</span><span class="p">},</span>
    <span class="s">'C'</span><span class="p">:</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">'B'</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="s">'D'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">11</span><span class="p">},</span>
    <span class="s">'D'</span><span class="p">:</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="mi">14</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'F'</span><span class="p">:</span> <span class="mi">9</span><span class="p">},</span>
    <span class="s">'E'</span><span class="p">:</span> <span class="p">{</span><span class="s">'B'</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="s">'C'</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="s">'F'</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
    <span class="s">'F'</span><span class="p">:</span> <span class="p">{</span><span class="s">'D'</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span> <span class="s">'E'</span><span class="p">:</span> <span class="mi">6</span><span class="p">}}</span>

<span class="n">unvisited</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">}</span>  <span class="c"># using None as +inf</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">current</span> <span class="o">=</span> <span class="s">'A'</span>
<span class="n">target</span> <span class="o">=</span> <span class="s">'F'</span>
<span class="n">currentDistance</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">unvisited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentDistance</span>

<span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">neighbour</span><span class="p">,</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">[</span><span class="n">current</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">unvisited</span><span class="p">:</span>
            <span class="n">newDistance</span> <span class="o">=</span> <span class="n">currentDistance</span> <span class="o">+</span> <span class="n">distance</span>
            <span class="k">if</span> <span class="n">unvisited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">unvisited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">newDistance</span><span class="p">:</span>
                <span class="n">unvisited</span><span class="p">[</span><span class="n">neighbour</span><span class="p">]</span> <span class="o">=</span> <span class="n">newDistance</span>

    <span class="n">visited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentDistance</span>
    <span class="k">del</span> <span class="n">unvisited</span><span class="p">[</span><span class="n">current</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">unvisited</span> <span class="ow">or</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">unvisited</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="c">#node[1] is current distance</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">break</span>

    <span class="n">current</span><span class="p">,</span> <span class="n">currentDistance</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">target</span><span class="p">])</span>
</code></pre></div>
<p>Some other interesting variations to think about</p>

<ul>
<li>What if the graph was unweighted? You can still use dijkstra&rsquo;s algorithm, using weights of 1.  The only problem is the time complexity. In this case it would be better to use a breadth first search.</li>
<li>Unweighted and directed?</li>
<li>weighted and directed?</li>
<li>Second shortest path?</li>
</ul>

          <br />
<p>
Thanks, <br>
  Adam Kenneweg
</p>
<p> 
</p>


        </section>
      </div>
      

      
        <div class="block">
  <div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = "akenneweg"; 
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
      
      <div class="block">
  
    <a target="_top"
       class="main" 
       href="/">
       Home
     </a>
  
    <a target="_top"
       class="main" 
       href="/blog">
       Blog
     </a>
  
    <a target="_top"
       class="main" 
       href="/projects">
       Projects
     </a>
  
    <a target="_top"
       class="main" 
       href="/gallery">
       Gallery
     </a>
  
    <a target="_top"
       class="main" 
       href="/resume.pdf">
       Resume
     </a>
  
</div>
    </div>
    <footer>
  <a href="http://github.com/muan/scribble" class="muted">built with Jekyll using Scribble theme</a>
  <br />
  <br />
  <img src="/images/scribble2.png" alt="scribble" /> 
</footer>
  </body>
</html>
