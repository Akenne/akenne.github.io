<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Adam Kenneweg - Computer Science - University of Waterloo - Blog and Projects</title>
    <description>I am Adam Kenneweg, a Computer Science student at the University of Waterloo, this is my blog where I write about my thoughts on school and life</description>
    <link></link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Interviewing tips for landing your first coop job</title>
        <description>&lt;p&gt;Jobmine season is the worst time at the University of Waterloo. Not only do you have classes and assignments, you now have to worry about getting a job for the next term, lest you end up jobless at home for four months while your friends are out making bank. This is for computer science/software engineering interviews, I don&amp;rsquo;t know how well this will transfer to other roles. &lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&quot;getting-the-interviews-the-resume&quot;&gt;Getting the interviews - the resume&lt;/h3&gt;

&lt;p&gt;The key to this is obviously your resume. &lt;strong&gt;I strongly recommend using LaTeX or html/css to design your resume&lt;/strong&gt;. It is usually impressive to the programmers reading your resume that you used programming to build your resume, and if they are an HR person, it probably looks better anyways. &lt;strong&gt;DO NOT USE THE PD TEMPLATE&lt;/strong&gt;. It is the most generic resume and employers are getting 5 of those clones for every unique resume.&lt;/p&gt;

&lt;p&gt;Your resume should highlight your experience, and even though you might not have any real employment, you should have lots of side projects on Github that you can showcase. Keep it to one page if you can, 2 if necessary. Any more and people will start laughing at it. Avoid putting your gradeschool and highschool achievements unless you are really reaching for content. You are a grown up now.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Cover letters are not necessary for the tech sector&lt;/strong&gt;, only put them if you really really want a specific job, and even then it is pretty useless. Employers will see right through generic ones. There are jobs that will require cover letters, but in my experience there is such a large amount of jobs its worth it to just ignore any that require them. You probably didn&amp;rsquo;t want to work there anyway.&lt;/p&gt;

&lt;p&gt;You should apply for 50+ jobs on your first term. I ended up applying to 80 before I got a job. During the first weekend listing, apply to 40-50, and the next weekend replace any that rejected you, to bring you up to 50 again. Interviews start after that second weekend. Don&amp;rsquo;t limit yourself to Toronto or Waterloo or your home town, as you are limiting yourself in life, holding yourself back. But don&amp;rsquo;t apply to jobs you don&amp;rsquo;t want to, unless you are in continuous. Working a crap job is not fun.&lt;/p&gt;

&lt;h3 id=&quot;the-interview&quot;&gt;The interview&lt;/h3&gt;

&lt;p&gt;Once you get interviews, make sure you read the descriptions thoroughly, check out their website, do a decent amount of research. Think of some genuine questions about the job, the company. Look on www.ratemycoopjob.com for some info on the company/salary. Reading &lt;em&gt;Cracking the coding interview&lt;/em&gt; is a great way to prepare yourself for some of the tricky questions.&lt;/p&gt;

&lt;p&gt;You should &lt;strong&gt;show up 5-10 minutes early&lt;/strong&gt;, wear business casual (or not, you are in tech). Please don&amp;rsquo;t wear a suit, you will get laughed at (outside of finance). Don&amp;rsquo;t bring anything other than a copy or two of your resume. If they want a laptop they will tell you to bring it. In my opinion an earlier slot is best, though not the first. If you go for a later one, they may have already decided on a candidate.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Once you are in the interview, your resume is useless&lt;/strong&gt;. It&amp;rsquo;s goal is to get you in, and maybe provide some talking points. It&amp;rsquo;s up to you to prove yourself now. Go into the interview with this in mind; The interviewer is looking not just for someone who knows what they are doing, but also someone they get along with. Treat them like you would a friend.&lt;/p&gt;

&lt;p&gt;Depending on the interview length, they may or may not ask technical questions. The goal of these in your mind is not to solve the question! It is to show how you think. If you spit out the answer you aren&amp;rsquo;t going to impress anything, walk them through your process of figuring it out. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Questions&lt;/strong&gt; - Ask some of the following&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Working hours&lt;/li&gt;
&lt;li&gt;Location&lt;/li&gt;
&lt;li&gt;Work environment&lt;/li&gt;
&lt;li&gt;Past co-op projects/ things that co-ops do&lt;/li&gt;
&lt;li&gt;Specific questions about the job/company !!!!&lt;/li&gt;
&lt;li&gt;Salary ~ MAKE SURE YOU ASK THIS EVERY TIME (unless you really, really messed up)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The interview might be the only time you will have the opportunity to find out the pay. The interviewer is used to this question, and it is not offensive. If they give vague answers try to press for a number. You might end up with &amp;ldquo;above average&amp;rdquo;, which probably refers to the hourly coop pay on the Waterloo website. &amp;ldquo;Market rate&amp;rdquo; means they  probably pay less than the average (think $11-16/h). Also never say you don&amp;rsquo;t have questions, it will make you appear to have no interest in the position.&lt;/p&gt;

&lt;h3 id=&quot;ranking&quot;&gt;Ranking&lt;/h3&gt;

&lt;p&gt;When deciding on offers and ranks, don&amp;rsquo;t let location stop you. Pick the job that will allow you the most growth. &lt;strong&gt;Pay is 2nd to experience&lt;/strong&gt;, as experience will lead to better pay in later coops, at a much better rate. Startups are great, and provide tons of hands on experience.&lt;/p&gt;

&lt;p&gt;The actual ranking strategy is a bit silly. If you don&amp;rsquo;t want a job rank it 9, but you might still get it. If you do want a job, rank it 1. If you get an offer and rank it 1, you will get it. If you rank it 2 and the person they ranked 2 ranks it 1, you get a 50/50 chance of getting the job.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t do tech support/IT work unless forced to when you are stuck in continuous. If offered in first round, I would not recommend taking it unless you have no side projects. Especially don&amp;rsquo;t do it two terms in a row, you are just shooting yourself in the foot. &lt;/p&gt;
</description>
        <pubDate>Tue, 12 May 2015 00:00:00 -0400</pubDate>
        <link>/blog/2015/05/12/Interviewing-tips-for-your-first-coop-job/</link>
        <guid isPermaLink="true">/blog/2015/05/12/Interviewing-tips-for-your-first-coop-job/</guid>
      </item>
    
      <item>
        <title>Software Engineering vs. Computer Science at the University of Waterloo</title>
        <description>&lt;h2 id=&quot;preface&quot;&gt;Preface&lt;/h2&gt;

&lt;p&gt;I spent a loooooot of time researching this when I was in high school. I imagine a lot of people similarly do. This is a big decision that needs to be made. If you want to end up doing work involving programming you are probably going to be picking one of these two. I ended up choosing computer science, but I will attempt to be unbiased when writing this post.&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&quot;entrance-difficulty&quot;&gt;Entrance Difficulty&lt;/h3&gt;

&lt;p&gt;You will need a higher average to get into Software Engineering, and you will also have to take the &amp;ldquo;engineering&amp;rdquo; classes in high school, chem and physics, which may be a struggle for some people. As far as I know the average to get in (with a decent AIF) this year was in 
the mid 90&amp;rsquo;s. For computer science, you only need calculus, functions, and English. The average for computer science is something like high 80&amp;rsquo;s, low 90&amp;rsquo;s (edit 2016: I heard it was 94 this year, be warned). There are a lot less people that get accepted into software engineering in comparison to computer science. &lt;strong&gt;Computer science is a lot easier to get into&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;courses&quot;&gt;Courses&lt;/h3&gt;

&lt;p&gt;Once you get in, the courseload for SE will be at a completely different level. In my computer science schedule, I had a total of 13 hours of class
every week. That&amp;rsquo;s including tutorials, which aren&amp;rsquo;t required. I know many engineers who&amp;rsquo;s schedule was pushing 40 hours. With class running
from 8 to 5. The time you are spending on school (both classes and homework), is going to be enormously more. &lt;/p&gt;

&lt;p&gt;As for the actual courses, in SE you are going to be taking 6 classes. One of them isn&amp;rsquo;t a real class, I don&amp;rsquo;t think you can fail it, but 
you will be spending time on it. You will be taking algebra and calculus, the same as CS, but at an easier level (less proofs). You will take a 
similar programming course as CS. But here is what I had problems with: you are required to take ECE courses. Specifically in first year, one that is about physics
and another that is about circuits. These are not easy classes. On the other hand, in computer science you take your programming, algebra and calculus, and then you get two
electives. These can be as easy or as hard as you choose. I personally chose a couple courses that interested me, and helped fill my required electives;
 astronomy, and western history pre 17th century.   &lt;/p&gt;

&lt;p&gt;The programming related courses you take will be pretty similar by the end, there isn&amp;rsquo;t really a difference in terms of practical vs theoretical. By that I mean
both programs have you take the same courses that will be relevant to your future job (an example is algorithms).&lt;/p&gt;

&lt;p&gt;Overall you will be taking a very rigid course schedule with SE. You will have to take a lot of engineering courses, which won&amp;rsquo;t really be very related
to your degree. There is a total of 11 &amp;ldquo;electives&amp;rdquo;. I say it like that because you don&amp;rsquo;t have much choice in them. You have strict requirements on what 
each one must be, so they won&amp;rsquo;t feel like electives.&lt;/p&gt;

&lt;p&gt;In computer science you can take 18 electives. &lt;strong&gt;EIGHTEEN!&lt;/strong&gt; These are &lt;strong&gt;all&lt;/strong&gt; truly electives, not &amp;ldquo;pick one of these computer science classes&amp;rdquo;. There are some requirements, such as a couple sciences,
a couple social sciences, a couple humanities. But other than that you are free to take whatever you desire. This can give you the option of getting a minor 
in anything you want, or taking more computer science classes.&lt;/p&gt;

&lt;p&gt;There is no debate here. &lt;strong&gt;SE is harder on all levels&lt;/strong&gt;, both time wise and difficulty. It&amp;rsquo;s your decision on whether or not it&amp;rsquo;s worth it.&lt;/p&gt;

&lt;h3 id=&quot;jobs&quot;&gt;Jobs&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;You will be getting the same jobs.&lt;/strong&gt; People will say that SE has more &amp;ldquo;prestige&amp;rdquo; but employers don&amp;rsquo;t particularly care. In some ways, I think computer science has the advantage,
because you have more free time to spend on side projects, leading to better jobs, and a better career. But in software engineering there is the cohort system, which might help you
out in terms of making connections. You could end up doing a bit more hardware related stuff in SE, but if that is your goal you should look at CE or ECE. Most schools
don&amp;rsquo;t have both a SE and computer science program, so employers are going to see it as the same thing.&lt;/p&gt;

&lt;p&gt;If you get accepted to just regular computer science, don&amp;rsquo;t think you can transfer into coop. I would consider other schools at that point, because what makes Waterloo great is the
coop program.&lt;/p&gt;

&lt;h3 id=&quot;other-stuff&quot;&gt;Other stuff&lt;/h3&gt;

&lt;p&gt;software engineering has the cohort system, which means you have same classes with the same people for your 5 years. I think this is really great, and is one of the best reasons
for picking software engineering. You get connections, and friends, which are both really great. You also end up being an engineer, which is pretty cool.&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Unless you are really into getting an engineering degree, or really, really love the whole cohort thing, &lt;em&gt;take Computer Science&lt;/em&gt;. You will have a better time in university, and you will
end up doing the same work anyway.&lt;/p&gt;
</description>
        <pubDate>Sun, 28 Dec 2014 00:00:00 -0500</pubDate>
        <link>/blog/2014/12/28/software-engineering-vs-computer-science/</link>
        <guid isPermaLink="true">/blog/2014/12/28/software-engineering-vs-computer-science/</guid>
      </item>
    
      <item>
        <title>Tips and thoughts on 1A Computer Science at the University of Waterloo</title>
        <description>&lt;p&gt;Here, I&amp;rsquo;ll talk about the classes I took in 1A as a CS student at the University of Waterloo.&lt;/p&gt;

&lt;p&gt;Some tips: &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Don&amp;rsquo;t space out your classes. Make them as close together as possible. You will have time to get to your next class.&lt;/li&gt;
&lt;li&gt;Online courses give you more free time, but don&amp;rsquo;t get left behind.&lt;/li&gt;
&lt;li&gt;A good time and a good prof are equally important.&lt;/li&gt;
&lt;li&gt;8am in high school is not the same as 8am in university. You will skip classes. Start your classes a bit later.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;Math 135: This class will destroy you. They teach this content in third year at other schools. Most people have not encountered this type of math before, the dreaded proof.
It requires you to think very critically, and I would compare it to solving puzzles. The class is just about various proofs, and even gets into a little encryption with RSA.
Weekly assignments, and two exams.&lt;/p&gt;

&lt;p&gt;Math 137: This class is pretty easy. The first half of it is high school review. Later, you will get a bit more into it, with proofs for some of the formulas you have to know.
Don&amp;rsquo;t underestimate the midterm, as our average was around 56%. The second half is more about anti derivatives and integrals, but I found the final much easier. Maybe
they were trying to raise the average. Weekly assignments, and two exams.&lt;/p&gt;

&lt;p&gt;CS 135: If you have any previous CS experience this will be a really easy class. If not you will be in a lot of trouble. The course is all about programming with Racket, a
dialect of lisp. The assignments are good, as you will be using the theoretical stuff you learned in class, doing problem solving and such. There are weekly tutorials,
but I never went, as I found they were a waste of time. Weekly assignments, and three exams. &lt;/p&gt;

&lt;p&gt;SCI 238: Astronomy. I loved this class, and it&amp;rsquo;s really easy, maybe because I took it online. There are 5 assignments which contain basic physics questions and then a final.
My lecturer, Michel Fich, is a great guy, and listening to his lectures is very enjoyable. It also fulfils one of those science electives, so I would recommend this 10/10.
Just make sure you listen to the lectures every week, and not cram 2000 slides the day before the exam.&lt;/p&gt;

&lt;p&gt;Hist 110: Western History. This is another great class. Every week you get a 3 hour lecture, which is basically a summary of some period of history. Starting with the Greeks and
ending with the reformation. You&amp;rsquo;ll leave the class with a solid knowledge of the history of the west, which is pretty great in my opinion. It&amp;rsquo;s relatively easy as well, you have to
write a one page reading log every week, and then two exams.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Dec 2014 00:00:00 -0500</pubDate>
        <link>/blog/2014/12/22/1a-computer-science-classes/</link>
        <guid isPermaLink="true">/blog/2014/12/22/1a-computer-science-classes/</guid>
      </item>
    
      <item>
        <title>WatIsFood - Hack the North 2014</title>
        <description>&lt;p&gt;Hack the north was the first hackathon I&amp;rsquo;ve ever been to. It was conveniently held on the University of Waterloo
campus. I went into it without a team, but with the goal of having something finished by then end, maybe an app or a 
website. I got set up with a team when I showed up, but we just weren&amp;rsquo;t compatible and ended up going seperate ways. I
walked around the building asking people if they needed an extra member until I found the team for me. Three other first years
who hadn&amp;rsquo;t started yet!&lt;/p&gt;

&lt;p&gt;After much debate we decided to make an android app, one that provides info about the food options available on the Waterloo campus.
Unfortunately, only myself, with a highschool java course under my belt, and one other member, with similar skills, had any programming experience, 
so we were tasked with the work. The other two members spent their time thinking up ideas and learning to code. I started by showing the other
member how Github worked, and he showed me how basic app design worked. We decided against just using the google maps api, and instead doing it 
from scratch. I went about doing the GUI design for the home screen, while the other member tried to figure out how to bring our idea to life.&lt;/p&gt;

&lt;p&gt;After many hours of frustrated Googling, I began to understand how the gui worked, and together with some mediocre photoshop skills, came up with a
half decent home page. Onto the main part of the program, we decided to display an image of a map of the campus, and put buttons on it related
to all the different food options. We figured out that we could pull info about all the different places to eat from the Waterloo api, and that we did.
We manually entered the xy coordinates, related them to the data, and suddenly (48 hours later) we had a working app.
We used the api data to display the name, whether it&amp;rsquo;s open, a short bio, and the hours. Using what we had, we were able to create
different options, one that showed only the open locations, and another that showed all locations.&lt;/p&gt;

&lt;p&gt;We were very proud of our very basic app, going from almost 0 experience with android apps to having a working product.
It wasn&amp;rsquo;t close to being the coolest thing to come out of the hackathon, but it was finished, and it was what we wanted to make.
The hackathon was a great experience, I developed new skills, met some new people, ate tons of free food, and had a lot of fun! 
I plan on going to many more in the future.  &lt;/p&gt;
</description>
        <pubDate>Thu, 18 Dec 2014 00:00:00 -0500</pubDate>
        <link>/projects/2014/12/18/WatIsFood---Hack-the-North-2014/</link>
        <guid isPermaLink="true">/projects/2014/12/18/WatIsFood---Hack-the-North-2014/</guid>
      </item>
    
      <item>
        <title>Spider Crawler - A different kind of backpack scanner</title>
        <description>&lt;h3 id=&quot;what&quot;&gt;What?&lt;/h3&gt;

&lt;p&gt;This is the biggest project I have ever made, and is written in Python. To a random observer it might seem very confusing. The very simplified goal, is to find
people who play Team Fortress 2, and have items that are worth a lot of money. I used to be very involved in this games economy, and some
items can sell for thousands of USD. The concept of it is that it scans peoples inventories, and then their friends inventories, and then their
friends inventories, etc. This way there is an endless supply of people to scan. The idea of a scanner has been around for a long time, but what
they would do is have you go onto a server hosting a game (with &amp;lt;30 people), scan the people on the server, and then change servers and repeat.
This is extremely time consuming, if you were quick you could scan maybe 20 people a minute. Mine does not require you to join a server (or even
own the game for that matter), and scans about 3000 users a minute, more or less depending on your computer speed. In the right hands this program
can make someone a lot of money, and I have had people donate to me due to their success with it. When I released it for free, it got around 400 downloads.&lt;/p&gt;

&lt;h3 id=&quot;how&quot;&gt;How?&lt;/h3&gt;

&lt;p&gt;The initial program would just scan the user, see if they have the item you are looking for, and if so, add them to a text file. It evolved to include
many many settings, such as how many threads you want to use, what items to look for, if the items have been traded, if the player owns the game,
if the item is untradable, if the user is online, the last time the user was online, and how many hours the user has played.&lt;/p&gt;

&lt;p&gt;What is being used to get the majority of this data is the steam api, which gives a lot of data in the JSON format. If the data matches all the
options the user has checked, then the players info will be output(his id). Now this was nice, but eventually I decided to give it a GUI, and this
was the first gui I ever made. I developed it using tkinter. Initially it looked like complete and utter garbage. Then I discovered how grids worked,
and then frames, and suddenly it wasn&amp;rsquo;t looking half bad. I got any users that fit the criteria to be put on a graph, which included their name, id,
items that you wanted and they had, and hours played. The user can then click the player on the graph and then go to their steam page, or backpack page
 (with different backpack options).&lt;/p&gt;

&lt;p&gt;It was also initially a lot slower, but I figured out that I could make use of multithreading, and the users/minute went from 100 to 3000. The program stores
a list of everyones friends(to a limit of 200), and each thread handles searching of these players, and then takes on a new player when done. The list of friends
is topped up if it goes below 100.&lt;/p&gt;

&lt;p&gt;Any data is also saved for future use (who you have scanned before, who met your criteria), and is saved via the pickle module. This keeps it in a nice array format.&lt;/p&gt;

&lt;p&gt;My biggest struggles with this project were understanding how JSON worked, figuring out multithreading, and GUI design. After many hours I am now proud to say I
 understand these concepts a whole lot better. It was very rewarding to have people actually using something I made myself. And to have them donate to me and thank
 me for the work I did was just amazing.&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Dec 2014 00:00:00 -0500</pubDate>
        <link>/projects/2014/12/13/Spider-Crawler---A-Team-Fortress-2-Backpack-Scanner/</link>
        <guid isPermaLink="true">/projects/2014/12/13/Spider-Crawler---A-Team-Fortress-2-Backpack-Scanner/</guid>
      </item>
    
      <item>
        <title>Chess.com Bot</title>
        <description>&lt;h3 id=&quot;what&quot;&gt;What?&lt;/h3&gt;

&lt;p&gt;This is probably my first big project, it was written in Python. The idea is that it plays (read: winds) chess for you (forever) 
on chess.com. This was just a fun project to play around with Python, and learn some new things. At the time I was playing a lot of chess,
and I decided I could probably make a program to play for me. I made this in April 2014.&lt;/p&gt;

&lt;h3 id=&quot;how&quot;&gt;How?&lt;/h3&gt;

&lt;p&gt;The way it works is that it will continously scan the board to see where the opponent moved, and then add this move (ex A2A4, meaning
you moved the piece on a2 to a4) to a log. Now there are chess engines that can take the state of the board and give the best move,
I used stockfish and critter. The program will send a line to the cmd of the chess engine, and the chess engine will spit out the
best move. The program will then take control of the mouse, and make the move. This repeats until the game is over, and then a new player
is found. &lt;/p&gt;

&lt;p&gt;The fun part for me was trying to make it seem human. I ended up doing a lot of things to make the program appear more human. Where the program 
picks up and drops pieces is randomized. The speed of mouse movement is random. The mouse idly moves randomly. The time between moves is based on 
the time the opponents last move took + some randomness (to simulate thinking). The time to actually move the pieces is random. The intelligence 
of the engine is much higher at beginning(to mirror human openings).&lt;/p&gt;

&lt;h3 id=&quot;problems&quot;&gt;Problems&lt;/h3&gt;

&lt;p&gt;I had some trouble with the program knowing which player you are, and the best method I found was changing your profile picture to a specific
image, and then the program scans the screen for the image and see which side you are on. I used a lot of &amp;ldquo;win32api&amp;rdquo;, in order to control mouse
movements. I also got to figure out how subprocesses work, and that running too many gives me a BSOD. Many times the program went bezerk and I lost
mouse control, forcing me to altf4 everything until I eventually figured out a way to force end the program. Because it uses x and y coordinates,
and people have different screen sizes, it took a while to figure out how to make sure the mouse is moving to the correct spots. I got it to work
by scanning the screen for the corner of the board, and then doing some math to see where the squares are.&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Overall this was really fun to make, and seeing my program actually work at the end was very rewarding. I was able to put a lot of my &amp;ldquo;theoretical&amp;rdquo;
 Python knowledge into practice.&lt;/p&gt;
</description>
        <pubDate>Wed, 10 Dec 2014 00:00:00 -0500</pubDate>
        <link>/projects/2014/12/10/Chess.com-Bot/</link>
        <guid isPermaLink="true">/projects/2014/12/10/Chess.com-Bot/</guid>
      </item>
    
  </channel>
</rss>
